操作系统实验报告：xv6 启动过程分析

姓名：张蓓蓓
学号：202311691047
班级：23计科2班
GitHub仓库：https://github.com/Beibei-Z-tech/Sophomore-year

一.实验环境
操作系统：Ubuntu 24.04 (ARM64/Emulated)
工具链：gcc, qemu-system-i386, git
主要修改文件：`bootasm.S`, `bootmain.c`, `entry.S`

二.任务完成情况

 Task 1: 搭建环境与运行
由于我使用的是Mac电脑，因此首先下载了UTM虚拟机配置Linux环境，其次下载了Ubuntu24.04并安装了gcc等需要的工具链
成功配置了 xv6 的开发环境，解决了 QEMU 和 GCC 版本不兼容的问题（通过修改 Makefile 移除 `-Werror`）。

Task 2 & 3: Bootloader 修改与可视化
为了观察启动流程，我在 `bootmain.c` 中添加了串口输出功能。
由于 Boot Sector 只有 512 字节的限制，直接添加字符串会导致 `boot block too large` 错误。我采取了以下优化措施：
1. 代码瘦身：移除了 `serial_puts`，只保留 `serial_putc`。
2. 简化输出：使用单个字符来标记启动阶段：
   - `'1'`: 进入 bootmain
   - `'2'`: ELF 头加载成功
   - `'3'`: 内核加载完毕

此外，我还在 `bootasm.S` 和 `entry.S` 中添加了关于“关闭中断”、“开启保护模式”和“开启分页”的中文注释。

三.实验结果截图
下图展示了系统成功启动，并打印出 `123` 序列，随后进入 Shell 的过程：
![截图](WechatIMG1484.jpg)
（实验结果截图图片名如上，已经提交到仓库里了，同名）


四.遇到的问题与解决方案
1. Boot Block 过大：初始修改导致编译后的 bootblock 超过 510 字节。通过使用 `-Os` 优化标志并精简打印字符解决了该问题。

2. Git 推送权限：解决了 GitHub 密码验证失效的问题，配置了 Personal Access Token 进行提交。

3. Mac电脑没有Linux环境，学会了下载UTM虚拟机并配置Linux环境。

五.个人总结与心得
本次实验是我第一次深入接触操作系统内核级别的开发。虽然代码量不大，但过程中的每一个报错都让我对“计算机是如何启动的”有了极其深刻的理解。
1. 对“硬限制”的敬畏：
在修改 `bootmain.c` 时，我第一次直观地感受到了硬件对软件的物理限制。512 字节的启动扇区寸土寸金，让我学会了如何权衡功能与体积，不仅要写出能跑的代码，还要写出“小而精”的代码。

2. 调试能力的提升：
从最初面对 QEMU 黑屏的无助，到学会使用串口输出字符（`'1', '2', '3'`）来定位内核崩溃的位置，我掌握了在没有高级调试器（如 IDE）支持下的“原始”调试方法。这种这一步步逼近真相的过程非常锻炼逻辑思维。

3. 工程素养的积累：
实验不仅是写代码，更是工程管理。这次实验让我踩遍了 Git 的坑（权限验证、分支冲突、大文件历史），最终通过 Token 配置和 Force Push 解决了问题。这些版本控制的经验在未来的团队协作中将非常宝贵。

总的来说，看着终端里跳出 `123` 和 `init: starting sh` 的那一刻，所有的折腾都变得值得。xv6 虽然古老，但它让我真正摸到了操作系统的脉搏。
